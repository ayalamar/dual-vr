getwd()
library(dplyr)
library(ggplot2)
# load data
dual30 <- read.csv('data/all_reaches_dual.csv', header = TRUE)
dual60 <- read.csv('data/all_reaches_dual_60.csv', header = TRUE)
single <- read.csv('data/all_reaches_single.csv', header = TRUE)
dual60 %>% head
single %>% head
unique(single$experiment)
unique(single$rotation)
unique(single$cursor_rotation)
View(single %>% filter(cursor_rotation == -30))
length(unique(single))
length(unique(single$ppid))
singlecube <- single %>%
filter(experiment == 'moveObject_R_Cube_1')
singlesphere <- single %>%
filter(experiment == 'moveObject_R_Sphere_1')
View(singlecube)
View(singlesphere)
unique(singlecube$cursor_rotation)
hh <- dual60 %>% filter(cursor_rotation == -30)
View(dual60)
hh <- dual60 %>% filter(dual_rotation == -30)
unique(dual60$dual_rotation)
hh <- dual60 %>% filter(dual_rotation == -60)
View(hh)
dual60$block_num %>% unique()
head(singlecube)
View(singlecube)
singlecube.sum <- singlecube %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), "first", "last"))
View(singlecube.sum)
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), "first", "last"))
View(singlecube.sum)
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), "first", "last")) %>%
ungroup() %>%
group_by(ppid, firstlast) %>%
summarise(meantheta = mean(theta, na.rm = TRUE))
View(singlecube.sum)
View(singlecube.sum)
ggplot(singlecube.sum, aes(x = firstlast, y = meantheta)) +
geom_col()
ggplot(singlecube.sum, aes(x = firstlast, y = meantheta)) +
geom_line()
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1, 2)) %>%
ungroup() %>%
group_by(ppid, firstlast) %>%
summarise(meantheta = mean(theta, na.rm = TRUE)) %>%
ggplot(aes(x = firstlast, y = meantheta)) +
geom_line()
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1, 2)) %>%
ungroup() %>%
group_by(ppid, firstlast) %>%
summarise(meantheta = mean(theta, na.rm = TRUE)) %>%
ggplot(aes(x = firstlast, y = meantheta)) +
geom_line()
View(singlecube.sum)
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1, 2)) %>%
ungroup() %>%
group_by(ppid, firstlast) %>%
summarise(meantheta = mean(theta, na.rm = TRUE))
ggplot(aes(x = firstlast, y = meantheta)) +
geom_line()
ggplot(aes(x = firstlast, y = meantheta)) +
geom_point()
View(singlecube.sum)
ggplot(data = singlecube.sum, aes(x = firstlast, y = meantheta)) +
geom_line()
install.packages("ggbeeswarm")
library(ggbeeswarm)
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1, 2)) %>%
ungroup() %>%
group_by(ppid, firstlast) %>%
summarise(meantheta = mean(theta, na.rm = TRUE),
sdtheta = sd(meantheta, na.rm = TRUE),
semtheta = sdtheta/sqrt(length(unique(ppid))))
singlecube.sum <- singlecube %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this is the rotated training block
filter(trial_num_in_block %in% c(1:3,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1, 2)) %>%
ungroup() %>%
group_by(ppid, firstlast) %>%
mutate(meantheta = mean(theta, na.rm = TRUE),
sdtheta = sd(meantheta, na.rm = TRUE),
semtheta = sdtheta/sqrt(length(unique(ppid))))
View(singlecube.sum)
rm(hh)
# analyze dual VR data
# cube: -30 or -60 / CCW rotation
# sphere: +30 or +60 / CW rotation
library(dplyr)
library(ggplot2)
library(ggbeeswarm)
# load data
dual30 <- read.csv('data/all_reaches_dual.csv', header = TRUE)
dual60 <- read.csv('data/all_reaches_dual_60.csv', header = TRUE)
single <- read.csv('data/all_reaches_single.csv', header = TRUE)
groupnames <- unique(single$experiment)
# AUTOMATE THIS PER GROUP - maybe one function for single groups, one for dual groups
# plot_single_errors <- function(group, ){}
for (groupname in groupnames) {
ppdf <- single %>% # get individual means so you can display individual learning curves
filter(experiment == groupname) %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this rotated training block needs to change PER EXPERIMENT
filter(trial_num_in_block %in% c(1:6,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1,
ifelse(trial_num_in_block %in% c(4:6), 2, 7))) %>% # last block is labeled "7" for plot aesthetics
ungroup() %>%
group_by(ppid, firstlast) %>% # get block means per ppid
summarise(pptheta = mean(theta, na.rm = TRUE),
group = groupname, rot = unique(cursor_rotation)) # CHANGE ROT!!!!!
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = groupname, rot = unique(rot))
print(unique(groupdf$group))
groupplot <- ggplot(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_point() +
geom_line(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_ribbon(data = groupdf,
aes(ymin = grouptheta - groupsem, ymax = grouptheta + groupsem),
alpha=0.4) +
geom_line(data = ppdf, aes(x = firstlast, y = pptheta, color = as.factor(ppid)), alpha = 0.1) +
coord_fixed(ratio = 1/7) +
ylim(-45,45) +
xlim(0,8) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
legend.title = element_blank(), legend.position = "none",
axis.text.x = element_blank()) +
ggtitle(groupname)
print(groupplot)
## PRINT SOME STATS
}
## next step: automate this for all groups;
## confirm what is theta , which ones got normalized?
View(dual30)
View(groupplot)
View(groupdf)
View(ppdf)
groupnames <- unique(single$experiment)
singles <- NA
for (groupname in groupnames) {
ppdf <- single %>% # get individual means so you can display individual learning curves
filter(experiment == groupname) %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this rotated training block needs to change PER EXPERIMENT
filter(trial_num_in_block %in% c(1:6,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1,
ifelse(trial_num_in_block %in% c(4:6), 2, 7))) %>% # last block is labeled "7" for plot aesthetics
ungroup() %>%
group_by(ppid, firstlast) %>% # get block means per ppid
summarise(pptheta = mean(theta, na.rm = TRUE),
group = groupname, rot = unique(cursor_rotation)) # CHANGE ROT!!!!!
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = groupname, rot = unique(rot))
groupplot <- ggplot(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_point() +
geom_line(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_ribbon(data = groupdf,
aes(ymin = grouptheta - groupsem, ymax = grouptheta + groupsem),
alpha=0.4) +
geom_line(data = ppdf, aes(x = firstlast, y = pptheta, color = as.factor(ppid)), alpha = 0.1) +
coord_fixed(ratio = 1/7) +
ylim(-45,45) +
xlim(0,8) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
legend.title = element_blank(), legend.position = "none",
axis.text.x = element_blank()) +
ggtitle(groupname)
print(groupplot)
if (singles == NA){
singles <- ppdf
} else {
singles <- rbind(singles, ppdf)
}
}
singles == NA
is.n(singles)
is.na(singles)
groupnames <- unique(single$experiment)
singles <- NA
for (groupname in groupnames) {
ppdf <- single %>% # get individual means so you can display individual learning curves
filter(experiment == groupname) %>%
group_by(ppid) %>%
filter(block_num == 16) %>% # this rotated training block needs to change PER EXPERIMENT
filter(trial_num_in_block %in% c(1:6,178:180)) %>%
mutate(firstlast = ifelse(trial_num_in_block %in% c(1:3), 1,
ifelse(trial_num_in_block %in% c(4:6), 2, 7))) %>% # last block is labeled "7" for plot aesthetics
ungroup() %>%
group_by(ppid, firstlast) %>% # get block means per ppid
summarise(pptheta = mean(theta, na.rm = TRUE),
group = groupname, rot = unique(cursor_rotation)) # CHANGE ROT!!!!!
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = groupname, rot = unique(rot))
groupplot <- ggplot(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_point() +
geom_line(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_ribbon(data = groupdf,
aes(ymin = grouptheta - groupsem, ymax = grouptheta + groupsem),
alpha=0.4) +
geom_line(data = ppdf, aes(x = firstlast, y = pptheta, color = as.factor(ppid)), alpha = 0.1) +
coord_fixed(ratio = 1/7) +
ylim(-45,45) +
xlim(0,8) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
legend.title = element_blank(), legend.position = "none",
axis.text.x = element_blank()) +
ggtitle(groupname)
print(groupplot)
if (is.na(singles)){
singles <- ppdf
} else {
singles <- rbind(singles, ppdf)
}
## PRINT SOME STATS
}
View(singles)
rm_mod<- aov(pptheta ~ firstlast + Error(ppid/firstlast),
data = singles)
summary(rm_mod)
rm_mod<- aov(pptheta ~ firstlast + rot + firstlast*rot + Error(ppid/firstlast),
data = singles)
summary(rm_mod)
install.packages("ez")
library(ez)
View(singles)
mod <- ezANOVA(data = singles,
dv = pptheta,
wid = ppid,
within = firstlast,
between = .(rot),
detailed = TRUE,
return_aov = TRUE)
print(mod)
View(dual30)
rots <- unique(dual30$obj_shape)
rots
rot = rots[1]
rot = rots[1]
rot
ppdf <- dual30 %>% # get individual means so you can display individual learning curves
filter(obj_shape == rot) %>%
group_by(ppid) %>%
filter(block_num %in% c(7,10)) %>% # rotated training blocks
mutate(trialn = 1:n()) %>%
filter(trialn %in% c(1:6,178:180))
View(ppdf)
View(dual30 %>% filter(ppid == 1))
unique(dual30)
unique(dual30@ppid)
unique(dual30$ppid)
View(dual30 %>% filter(ppid == 1))
rot
rot
paste('cat',rot)
paste('cat',rot, sep=)
paste('cat',rot, sep="")
ppdf <- dual30 %>% # get individual means so you can display individual learning curves
filter(obj_shape == rot) %>%
group_by(ppid) %>%
filter(block_num %in% c(7,10)) %>% # rotated training blocks
mutate(trialn = 1:n()) %>% # rewrite new trial numbers because rotations are interleaved
filter(trialn %in% c(1:6,178:180)) %>%
mutate(firstlast = ifelse(trialn %in% c(1:3), 1,
ifelse(trialn %in% c(4:6), 2, 7))) %>% # last block is labeled "7" for plot aesthetics
ungroup() %>%
group_by(ppid, firstlast) %>% # get block means per ppid
summarise(pptheta = mean(theta, na.rm = TRUE),
group = paste('dual', rot, sep = ""), rot = unique(cursor_rotation))
ppdf <- dual30 %>% # get individual means so you can display individual learning curves
filter(obj_shape == rot) %>%
group_by(ppid) %>%
filter(block_num %in% c(7,10)) %>% # rotated training blocks
mutate(trialn = 1:n()) %>% # rewrite new trial numbers because rotations are interleaved
filter(trialn %in% c(1:6,178:180)) %>%
mutate(firstlast = ifelse(trialn %in% c(1:3), 1,
ifelse(trialn %in% c(4:6), 2, 7))) %>% # last block is labeled "7" for plot aesthetics
ungroup() %>%
group_by(ppid, firstlast) %>% # get block means per ppid
summarise(pptheta = mean(theta, na.rm = TRUE),
group = paste('dual', rot, sep = ""), rot = unique(dual_rotation))
View(ppdf)
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = groupname, rot = unique(rot))
View(groupdf)
groupplot <- ggplot(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_point() +
geom_line(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_ribbon(data = groupdf,
aes(ymin = grouptheta - groupsem, ymax = grouptheta + groupsem),
alpha=0.4) +
geom_line(data = ppdf, aes(x = firstlast, y = pptheta, color = as.factor(ppid)), alpha = 0.1) +
coord_fixed(ratio = 1/7) +
ylim(-45,45) +
xlim(0,8) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
legend.title = element_blank(), legend.position = "none",
axis.text.x = element_blank()) +
ggtitle(rot)
print(groupplot)
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = paste('dual', rot, sep = ""), rot = unique(rot))
rot
paste('dual', rot, sep = "")
(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = paste('dual', rot, sep = ""), rot = unique(rot))
ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = paste('dual', rot, sep = ""), rot = unique(rot))
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = unique(group), rot = unique(rot))
View(groupdf)
ggplot(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_point() +
geom_line(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_ribbon(data = groupdf,
aes(ymin = grouptheta - groupsem, ymax = grouptheta + groupsem),
alpha = 0.4) +
geom_line(data = ppdf, aes(x = firstlast, y = pptheta, color = as.factor(ppid)), alpha = 0.1) +
coord_fixed(ratio = 1/7) +
ylim(-45,45) +
xlim(0,8) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
legend.title = element_blank(), legend.position = "none",
axis.text.x = element_blank()) +
ggtitle(paste('dual', rot, sep = ""))
mod <- ezANOVA(data = duals,
dv = pptheta,
wid = ppid,
within = .(firstlast, rot),
detailed = TRUE,
return_aov = TRUE)
print(mod)
duals
dual30 <- read.csv('data/all_reaches_dual.csv', header = TRUE)
dual60 <- read.csv('data/all_reaches_dual_60.csv', header = TRUE)
dual30 <- dual30 %>%
mutate(dualgroup = 'dual30')
dual60 <- dual60 %>%
mutate(dualgroup = 'dual60')
dual <- rbind(dual30, dual60)
dualgroups <- unique(dual$dualgroup)
rots <- unique(dual$obj_shape)
duals <- NA
dualgroups
dual30 <- dual30 %>%
mutate(dualgroup = 'dual30')
dual60 <- dual60 %>%
mutate(dualgroup = 'dual60')
dual <- rbind(dual30, dual60)
dualgroups <- unique(dual$dualgroup)
rots <- unique(dual$obj_shape)
duals <- NA
dual30 <- read.csv('data/all_reaches_dual.csv', header = TRUE)
dual60 <- read.csv('data/all_reaches_dual_60.csv', header = TRUE)
dual30 <- dual30 %>%
mutate(dualgroup = 'dual30')
dual60 <- dual60 %>%
mutate(dualgroup = 'dual60')
dual <- rbind(dual30, dual60)
dualgroups <- unique(dual$dualgroup)
rots <- unique(dual$obj_shape)
duals <- NA
for (group in dualgroups){
for (rot in rots){
ppdf <- dual %>% # get individual means so you can display individual learning curves
filter(dualgroup == group) %>%
filter(obj_shape == rot) %>%
group_by(ppid) %>%
filter(block_num %in% c(7,10)) %>% # rotated training blocks
mutate(trialn = 1:n()) %>% # rewrite new trial numbers because rotations are interleaved
filter(trialn %in% c(1:6,178:180)) %>%
mutate(firstlast = ifelse(trialn %in% c(1:3), 1,
ifelse(trialn %in% c(4:6), 2, 7))) %>% # last block is labeled "7" for plot aesthetics
ungroup() %>%
group_by(ppid, firstlast) %>% # get block means per ppid
summarise(pptheta = mean(theta, na.rm = TRUE),
group = paste('dual', rot, sep = ""), rot = unique(dual_rotation))
groupdf <- ppdf %>% # get block means per group, for plots
group_by(firstlast) %>%
summarise(grouptheta = mean(pptheta, na.rm = TRUE),
groupsd = sd(pptheta, na.rm = TRUE),
groupsem = groupsd/sqrt(length(unique(ppid))),
group = unique(group), rot = unique(rot))
groupplot <- ggplot(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_point() +
geom_line(data = groupdf, aes(x = firstlast, y = grouptheta)) +
geom_ribbon(data = groupdf,
aes(ymin = grouptheta - groupsem, ymax = grouptheta + groupsem),
alpha = 0.4) +
geom_line(data = ppdf, aes(x = firstlast, y = pptheta, color = as.factor(ppid)), alpha = 0.1) +
coord_fixed(ratio = 1/7) +
ylim(-45,45) +
xlim(0,8) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
legend.title = element_blank(), legend.position = "none",
axis.text.x = element_blank()) +
ggtitle(paste('dual', rot, sep = ""))
print(groupplot)
if (is.na(duals)){
duals <- ppdf
} else {
duals <- rbind(duals, ppdf)
}
}
}
duals
View(duals)
mod <- ezANOVA(data = duals,
dv = pptheta,
wid = ppid,
within = .(firstlast, rot),
between = group,
detailed = TRUE,
return_aov = TRUE)
print(mod)
View(dual60)
View(dual60)
View(duals)
mod <- ezANOVA(data = duals,
dv = pptheta,
wid = ppid,
within = .(firstlast),
between = group,
detailed = TRUE,
return_aov = TRUE)
print(mod)
View(rm_mod)
View(single)
View(singlecube.sum)
View(singles)
check <- dual60 %>% filter(trial_num %in% c(440,441,442)) %>% select(ppid, theta)
View(check)
hist(check$theta)
